\section{Parser}

In our recursive-descent Parser we implemented all EBNF production rules as
methods. The production rules of our EBNF allows alternatives, repetitions and optional parts.
Figure TODO shows a dependence diagram of the parser methods.  

To ensure that our EBNF is LL(1) conform, we created the a list with the first sets.
The parser compares the actual token with the first-sets symbol
and takes decisions between alternatives. 
To guarantee that the decision between two alternatives is correct, the first
set of the alternatives must be disjunctive. We checked our EBNF with the Parser tool: coco, to ensure we are are LL(1) conform.
% coco page http://www.ssw.uni-linz.ac.at/Research/Projects/Coco/


\subsection{First Symbols (first sets)}
\begin{tabular}{p{4cm}l}
program & "package" "import" "public" \\
packageDeclaration & "package" \\
packageImport & "import" \\
classDeclaration & "public" \\
identifier & simpleIdentifier \\
classBlock & simpleIdentifier "public" "String" "String[]" "int" "boolean" "char" "int[]" "boolean[]" "char[]" \\
objectDeclaration & simpleIdentifier \\
simpleDeclaration & "String" "String[]" "int" "boolean" "char" "int[]" "boolean[]" "char[]" \\
methodDeclaration & "public" \\
object & simpleIdentifier \\
objectDeclarationSuffix & simpleIdentifier \\
primitiveDeclaration & "int" "boolean" "char" \\
primitiveArrayDeclaration & "int[]" "boolean[]" "char[]" \\
stringDeclaration & "String" \\
stringArrayDeclaration & "String[]" \\
datatype & simpleIdentifier "String" "int" "boolean" "char" \\
datatypeDescriptor & simpleIdentifier "String" "int" "boolean" "char" \\
bodyBlock & simpleIdentifier "String" "String[]" "while" "if" "return" "int" "boolean" "char" "int[]" "boolean[]" "char[]" \\
primitive & "int" "boolean" "char" \\
assignmentSuffix & equal \\
primitiveArray & "int[]" "boolean[]" "char[]" \\
objectDeclarationAssignmentMethodcall & simpleIdentifier \\
arrayDeclarationSuffix & equal simpleIdentifier "[" \\
methodCallSuffix & "(" \\
expression & not number simpleIdentifier StringValue charValue "NULL" "-" "true" "false" \\
arraySelector & "[" \\
whileStatement & "while" \\
ifStatement & "if" \\
returnStatement & "return" \\
condition & not number simpleIdentifier StringValue charValue "NULL" "-" "true" "false" \\
value & not number simpleIdentifier StringValue charValue "NULL" "-" "true" "false" \\
intValue & number "-" \\
booleanValue & "true" "false" \\
factor & not number simpleIdentifier StringValue charValue "NULL" "-" "true" "false" \\
term & not number simpleIdentifier StringValue charValue "NULL" "-" "true" "false" \\
\end{tabular}
%
\section{Syntax Error Handling}
The Compiler is able to detect a certain amount of Syntax Errors. We distinguish between two error levels : week and strong errors.
\begin{itemize}
  \item \textbf{Week Errors} will be fixed by the parser. 
  \item \textbf{Strong Errors} can not be fixed. 
\end{itemize}

\subsection{Week Errors (Warnings)}
\label{label_week_errors}
Week errors are missing tokens which will be inserted by the parser.
The code generator never get notice about those errors. When a week error occurs a warning will be displaced, the token will be
inserted, parsing and code generation continues.
Compiler is able to detect and correct following week errors:
\begin{itemize}
  \item any missing \";\"
  \item any missing ")" "\{" "\}" "]" 
  \item near all missing "(" except at an object declaration, because we have to distinguish between "[" and "(" 
  \item in class declarations a missing ``class'' will be fixed.
  \item in method declarations when return type is missing (TODO !!!)
  \item in method declarations when ``static'' is missing
  \item in parameterlists we will detect and correct missing ","
\end{itemize}

\subsection{Strong Errors}
\label{label_strong_errors}
Strong Errors can be syntax errors as well as invalid symbols or invalid words. When a strong error occurs the parser displaces a error
message and the code generation will be stopped. The parser goes to the next strong symbol and continue parsing. In our parser
implementation we have sync operation implemented in three methods. (TODO)
Strong Errors can be:
\begin{itemize}
  \item misplaced tokens. When the current token does not correspond to EBNF rules, except of week errors.
  \item any missing identifiers.
  \item any illegal terminal symbols, like identifier starting with a digit. This kind of error detects the scanner, and a
  error token will be delivered to the parser.
\end{itemize}
\begin{quotation}
For example, if we had a production
\begin{verbatim}
A = a b c.
\end{verbatim}
for which the input was
\begin{verbatim}
a x c
\end{verbatim}
the parser reports
\begin{verbatim}
TODO Message
\end{verbatim}
\end{quotation}
